/**
 * MerakiDashboardAPILib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

'use strict';

const _request = require('../Http/Client/RequestClient');
const _configuration = require('../configuration');
const _apiHelper = require('../APIHelper');
const _baseController = require('./BaseController');

class WirelessController {
    /**
     * Return the bluetooth settings for a wireless device
     *
     * @param {string} serial TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getDeviceWirelessBluetoothSettings(serial, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/devices/{serial}/wireless/bluetooth/settings';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            serial: { value: serial, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Update the bluetooth settings for a wireless device
     *
     * @param {string} serial TODO: type description here
     * @param {UpdateDeviceWirelessBluetoothSettings} updateDeviceWirelessBluetoothSettings (option
     * al)
     * TODO:
     * type
     * descrip
     * tion
     * here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateDeviceWirelessBluetoothSettings(serial,
        updateDeviceWirelessBluetoothSettings,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/devices/{serial}/wireless/bluetooth/settings';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            serial: { value: serial, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(updateDeviceWirelessBluetoothSettings),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Aggregated connectivity info for a given AP on this network
     *
     * @param {string} serial TODO: type description here
     * @param {string} t0 (optional) The beginning of the timespan for the data. The maximum
     * lookback period is 180 days from today.
     * @param {string} t1 (optional) The end of the timespan for the data. t1 can be a maximum of 7
     * days after t0.
     * @param {double} timespan (optional) The timespan for which the information will be fetched.
     * If specifying timespan, do not specify parameters t0 and t1. The
     * value must be in seconds and be less than or equal to 7 days.
     * @param {BandEnum} band (optional) Filter results by band (either '2.4' or '5'). Note that
     * data prior to February 2020 will not have band information.
     * @param {int} ssid (optional) Filter results by SSID
     * @param {int} vlan (optional) Filter results by VLAN
     * @param {string} apTag (optional) Filter results by AP Tag
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getDeviceWirelessConnectionStats(serial,
        t0,
        t1,
        timespan,
        band,
        ssid,
        vlan,
        apTag,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/devices/{serial}/wireless/connectionStats';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            serial: { value: serial, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            t0,
            t1,
            timespan,
            band: (band !== null) ? band : null,
            ssid,
            vlan,
            apTag,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Aggregated latency info for a given AP on this network
     *
     * @param {string} serial TODO: type description here
     * @param {string} t0 (optional) The beginning of the timespan for the data. The maximum
     * lookback period is 180 days from today.
     * @param {string} t1 (optional) The end of the timespan for the data. t1 can be a maximum of 7
     * days after t0.
     * @param {double} timespan (optional) The timespan for which the information will be fetched.
     * If specifying timespan, do not specify parameters t0 and t1. The
     * value must be in seconds and be less than or equal to 7 days.
     * @param {BandEnum} band (optional) Filter results by band (either '2.4' or '5'). Note that
     * data prior to February 2020 will not have band information.
     * @param {int} ssid (optional) Filter results by SSID
     * @param {int} vlan (optional) Filter results by VLAN
     * @param {string} apTag (optional) Filter results by AP Tag
     * @param {string} fields (optional) Partial selection: If present, this call will return only
     * the selected fields of ["rawDistribution", "avg"]. All fields will be
     * returned by default. Selected fields must be entered as a comma
     * separated string.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getDeviceWirelessLatencyStats(serial,
        t0,
        t1,
        timespan,
        band,
        ssid,
        vlan,
        apTag,
        fields,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/devices/{serial}/wireless/latencyStats';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            serial: { value: serial, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            t0,
            t1,
            timespan,
            band: (band !== null) ? band : null,
            ssid,
            vlan,
            apTag,
            fields,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Return the radio settings of a device
     *
     * @param {string} serial TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getDeviceWirelessRadioSettings(serial, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/devices/{serial}/wireless/radio/settings';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            serial: { value: serial, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Update the radio settings of a device
     *
     * @param {string} serial TODO: type description here
     * @param {UpdateDeviceWirelessRadioSettings} updateDeviceWirelessRadioSettings (optional) TODO:
     * type
     * description
     * here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateDeviceWirelessRadioSettings(serial,
        updateDeviceWirelessRadioSettings,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/devices/{serial}/wireless/radio/settings';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            serial: { value: serial, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(updateDeviceWirelessRadioSettings),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Return the SSID statuses of an access point
     *
     * @param {string} serial TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getDeviceWirelessStatus(serial, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/devices/{serial}/wireless/status';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            serial: { value: serial, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * List Air Marshal scan results from a network
     *
     * @param {string} networkId TODO: type description here
     * @param {string} t0 (optional) The beginning of the timespan for the data. The maximum
     * lookback period is 31 days from today.
     * @param {double} timespan (optional) The timespan for which the information will be fetched.
     * If specifying timespan, do not specify parameter t0. The value must
     * be in seconds and be less than or equal to 31 days. The default is
     * 7 days.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessAirMarshal(networkId, t0, timespan, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/airMarshal';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            t0,
            timespan,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Return alternate management interface and devices with IP assigned
     *
     * @param {string} networkId TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessAlternateManagementInterface(networkId, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/alternateManagementInterface';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Update alternate management interface and device static IP
     *
     * @param {string} networkId TODO: type description here
     * @param {UpdateNetworkWirelessAlternateManagementInterface} updateNetworkWirelessAlternateManagementInterface (optional) TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateNetworkWirelessAlternateManagementInterface(networkId,
        updateNetworkWirelessAlternateManagementInterface,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/alternateManagementInterface';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(updateNetworkWirelessAlternateManagementInterface),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Return the billing settings of this network
     *
     * @param {string} networkId TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessBilling(networkId, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/billing';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Update the billing settings
     *
     * @param {string} networkId TODO: type description here
     * @param {UpdateNetworkWirelessBilling} updateNetworkWirelessBilling (optional) TODO: type
     * description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateNetworkWirelessBilling(networkId, updateNetworkWirelessBilling, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/billing';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(updateNetworkWirelessBilling),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Return the Bluetooth settings for a network. <a href="https://documentation.meraki.
     * com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)">Bluetooth settings</a> must be enabled on the
     * network.
     *
     * @param {string} networkId TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessBluetoothSettings(networkId, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/bluetooth/settings';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Update the Bluetooth settings for a network. See the docs page for <a href="https:
     * //documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)">Bluetooth settings</a>.
     *
     * @param {string} networkId TODO: type description here
     * @param {UpdateNetworkWirelessBluetoothSettings} updateNetworkWirelessBluetoothSettings (opti
     * onal)
     * TODO:
     * type
     * descr
     * iptio
     * n
     * here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateNetworkWirelessBluetoothSettings(networkId,
        updateNetworkWirelessBluetoothSettings,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/bluetooth/settings';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(updateNetworkWirelessBluetoothSettings),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Return AP channel utilization over time for a device or network client
     *
     * @param {string} networkId TODO: type description here
     * @param {string} t0 (optional) The beginning of the timespan for the data. The maximum
     * lookback period is 31 days from today.
     * @param {string} t1 (optional) The end of the timespan for the data. t1 can be a maximum of
     * 31 days after t0.
     * @param {double} timespan (optional) The timespan for which the information will be fetched.
     * If specifying timespan, do not specify parameters t0 and t1. The
     * value must be in seconds and be less than or equal to 31 days. The
     * default is 7 days.
     * @param {int} resolution (optional) The time resolution in seconds for returned data. The
     * valid resolutions are: 600, 1200, 3600, 14400, 86400. The default is
     * 86400.
     * @param {bool} autoResolution (optional) Automatically select a data resolution based on the
     * given timespan; this overrides the value specified by the
     * 'resolution' parameter. The default setting is false.
     * @param {string} clientId (optional) Filter results by network client to return per-device,
     * per-band AP channel utilization metrics inner joined by the queried
     * client's connection history.
     * @param {string} deviceSerial (optional) Filter results by device to return AP channel
     * utilization metrics for the queried device; either :band or :
     * clientId must be jointly specified.
     * @param {string} apTag (optional) Filter results by AP tag to return AP channel utilization
     * metrics for devices labeled with the given tag; either :clientId or :
     * deviceSerial must be jointly specified.
     * @param {BandEnum} band (optional) Filter results by band (either '2.4' or '5').
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessChannelUtilizationHistory(networkId,
        t0,
        t1,
        timespan,
        resolution,
        autoResolution,
        clientId,
        deviceSerial,
        apTag,
        band,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/channelUtilizationHistory';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            t0,
            t1,
            timespan,
            resolution,
            autoResolution,
            clientId,
            deviceSerial,
            apTag,
            band: (band !== null) ? band : null,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Return wireless client counts over time for a network, device, or network client
     *
     * @param {string} networkId TODO: type description here
     * @param {string} t0 (optional) The beginning of the timespan for the data. The maximum
     * lookback period is 31 days from today.
     * @param {string} t1 (optional) The end of the timespan for the data. t1 can be a maximum of
     * 31 days after t0.
     * @param {double} timespan (optional) The timespan for which the information will be fetched.
     * If specifying timespan, do not specify parameters t0 and t1. The
     * value must be in seconds and be less than or equal to 31 days. The
     * default is 7 days.
     * @param {int} resolution (optional) The time resolution in seconds for returned data. The
     * valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The
     * default is 86400.
     * @param {bool} autoResolution (optional) Automatically select a data resolution based on the
     * given timespan; this overrides the value specified by the
     * 'resolution' parameter. The default setting is false.
     * @param {string} clientId (optional) Filter results by network client to return per-device
     * client counts over time inner joined by the queried client's
     * connection history.
     * @param {string} deviceSerial (optional) Filter results by device.
     * @param {string} apTag (optional) Filter results by AP tag.
     * @param {BandEnum} band (optional) Filter results by band (either '2.4' or '5').
     * @param {int} ssid (optional) Filter results by SSID number.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessClientCountHistory(networkId,
        t0,
        t1,
        timespan,
        resolution,
        autoResolution,
        clientId,
        deviceSerial,
        apTag,
        band,
        ssid,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/clientCountHistory';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            t0,
            t1,
            timespan,
            resolution,
            autoResolution,
            clientId,
            deviceSerial,
            apTag,
            band: (band !== null) ? band : null,
            ssid,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Aggregated connectivity info for this network, grouped by clients
     *
     * @param {string} networkId TODO: type description here
     * @param {string} t0 (optional) The beginning of the timespan for the data. The maximum
     * lookback period is 180 days from today.
     * @param {string} t1 (optional) The end of the timespan for the data. t1 can be a maximum of 7
     * days after t0.
     * @param {double} timespan (optional) The timespan for which the information will be fetched.
     * If specifying timespan, do not specify parameters t0 and t1. The
     * value must be in seconds and be less than or equal to 7 days.
     * @param {BandEnum} band (optional) Filter results by band (either '2.4' or '5'). Note that
     * data prior to February 2020 will not have band information.
     * @param {int} ssid (optional) Filter results by SSID
     * @param {int} vlan (optional) Filter results by VLAN
     * @param {string} apTag (optional) Filter results by AP Tag
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessClientsConnectionStats(networkId,
        t0,
        t1,
        timespan,
        band,
        ssid,
        vlan,
        apTag,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/clients/connectionStats';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            t0,
            t1,
            timespan,
            band: (band !== null) ? band : null,
            ssid,
            vlan,
            apTag,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Aggregated latency info for this network, grouped by clients
     *
     * @param {string} networkId TODO: type description here
     * @param {string} t0 (optional) The beginning of the timespan for the data. The maximum
     * lookback period is 180 days from today.
     * @param {string} t1 (optional) The end of the timespan for the data. t1 can be a maximum of 7
     * days after t0.
     * @param {double} timespan (optional) The timespan for which the information will be fetched.
     * If specifying timespan, do not specify parameters t0 and t1. The
     * value must be in seconds and be less than or equal to 7 days.
     * @param {BandEnum} band (optional) Filter results by band (either '2.4' or '5'). Note that
     * data prior to February 2020 will not have band information.
     * @param {int} ssid (optional) Filter results by SSID
     * @param {int} vlan (optional) Filter results by VLAN
     * @param {string} apTag (optional) Filter results by AP Tag
     * @param {string} fields (optional) Partial selection: If present, this call will return only
     * the selected fields of ["rawDistribution", "avg"]. All fields will be
     * returned by default. Selected fields must be entered as a comma
     * separated string.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessClientsLatencyStats(networkId,
        t0,
        t1,
        timespan,
        band,
        ssid,
        vlan,
        apTag,
        fields,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/clients/latencyStats';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            t0,
            t1,
            timespan,
            band: (band !== null) ? band : null,
            ssid,
            vlan,
            apTag,
            fields,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Aggregated connectivity info for a given client on this network. Clients are identified by
     * their MAC.
     *
     * @param {string} networkId TODO: type description here
     * @param {string} clientId TODO: type description here
     * @param {string} t0 (optional) The beginning of the timespan for the data. The maximum
     * lookback period is 180 days from today.
     * @param {string} t1 (optional) The end of the timespan for the data. t1 can be a maximum of 7
     * days after t0.
     * @param {double} timespan (optional) The timespan for which the information will be fetched.
     * If specifying timespan, do not specify parameters t0 and t1. The
     * value must be in seconds and be less than or equal to 7 days.
     * @param {BandEnum} band (optional) Filter results by band (either '2.4' or '5'). Note that
     * data prior to February 2020 will not have band information.
     * @param {int} ssid (optional) Filter results by SSID
     * @param {int} vlan (optional) Filter results by VLAN
     * @param {string} apTag (optional) Filter results by AP Tag
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessClientConnectionStats(networkId,
        clientId,
        t0,
        t1,
        timespan,
        band,
        ssid,
        vlan,
        apTag,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/clients/{clientId}/connectionStats';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            clientId: { value: clientId, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            t0,
            t1,
            timespan,
            band: (band !== null) ? band : null,
            ssid,
            vlan,
            apTag,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * List the wireless connectivity events for a client within a network in the timespan.
     *
     * @param {string} networkId TODO: type description here
     * @param {string} clientId TODO: type description here
     * @param {int} perPage (optional) The number of entries per page returned. Acceptable range is
     * 3 - 1000.
     * @param {string} startingAfter (optional) A token used by the server to indicate the start of
     * the page. Often this is a timestamp or an ID but it is not
     * limited to those. This parameter should not be defined by
     * client applications. The link for the first, last, prev, or
     * next page in the HTTP Link header should define it.
     * @param {string} endingBefore (optional) A token used by the server to indicate the end of
     * the page. Often this is a timestamp or an ID but it is not
     * limited to those. This parameter should not be defined by
     * client applications. The link for the first, last, prev, or
     * next page in the HTTP Link header should define it.
     * @param {string} t0 (optional) The beginning of the timespan for the data. The maximum
     * lookback period is 31 days from today.
     * @param {string} t1 (optional) The end of the timespan for the data. t1 can be a maximum of
     * 31 days after t0.
     * @param {double} timespan (optional) The timespan for which the information will be fetched.
     * If specifying timespan, do not specify parameters t0 and t1. The
     * value must be in seconds and be less than or equal to 31 days. The
     * default is 1 day.
     * @param {array} types (optional) A list of event types to include. If not specified, events
     * of all types will be returned. Valid types are 'assoc', 'disassoc',
     * 'auth', 'deauth', 'dns', 'dhcp', 'roam', 'connection' and/or 'sticky'.
     * @param {array} includedSeverities (optional) A list of severities to include. If not
     * specified, events of all severities will be returned.
     * Valid severities are 'good', 'info', 'warn' and/or 'bad'.
     * @param {BandEnum} band (optional) Filter results by band (either '2.4' or '5').
     * @param {SsidNumberEnum} ssidNumber (optional) An SSID number to include. If not specified,
     * events for all SSIDs will be returned.
     * @param {string} deviceSerial (optional) Filter results by an AP's serial number.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessClientConnectivityEvents(networkId,
        clientId,
        perPage,
        startingAfter,
        endingBefore,
        t0,
        t1,
        timespan,
        types,
        includedSeverities,
        band,
        ssidNumber,
        deviceSerial,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/clients/{clientId}/connectivityEvents';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            clientId: { value: clientId, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            perPage,
            startingAfter,
            endingBefore,
            t0,
            t1,
            timespan,
            types: (types !== null) ? types : null,
            includedSeverities: (includedSeverities !== null) ? includedSeverities : null,
            band: (band !== null) ? band : null,
            ssidNumber: (ssidNumber !== null) ? ssidNumber : null,
            deviceSerial,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Return the latency history for a client. Clients can be identified by a client key or
     * either the MAC or IP depending on whether the network uses Track-by-IP. The latency data
     * is from a sample of 2% of packets and is grouped into 4 traffic categories: background,
     * best effort, video, voice. Within these categories the sampled packet counters are
     * bucketed by latency in milliseconds.
     *
     * @param {string} networkId TODO: type description here
     * @param {string} clientId TODO: type description here
     * @param {string} t0 (optional) The beginning of the timespan for the data. The maximum
     * lookback period is 791 days from today.
     * @param {string} t1 (optional) The end of the timespan for the data. t1 can be a maximum of
     * 791 days after t0.
     * @param {double} timespan (optional) The timespan for which the information will be fetched.
     * If specifying timespan, do not specify parameters t0 and t1. The
     * value must be in seconds and be less than or equal to 791 days. The
     * default is 1 day.
     * @param {int} resolution (optional) The time resolution in seconds for returned data. The
     * valid resolutions are: 86400. The default is 86400.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessClientLatencyHistory(networkId,
        clientId,
        t0,
        t1,
        timespan,
        resolution,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/clients/{clientId}/latencyHistory';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            clientId: { value: clientId, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            t0,
            t1,
            timespan,
            resolution,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Aggregated latency info for a given client on this network. Clients are identified by
     * their MAC.
     *
     * @param {string} networkId TODO: type description here
     * @param {string} clientId TODO: type description here
     * @param {string} t0 (optional) The beginning of the timespan for the data. The maximum
     * lookback period is 180 days from today.
     * @param {string} t1 (optional) The end of the timespan for the data. t1 can be a maximum of 7
     * days after t0.
     * @param {double} timespan (optional) The timespan for which the information will be fetched.
     * If specifying timespan, do not specify parameters t0 and t1. The
     * value must be in seconds and be less than or equal to 7 days.
     * @param {BandEnum} band (optional) Filter results by band (either '2.4' or '5'). Note that
     * data prior to February 2020 will not have band information.
     * @param {int} ssid (optional) Filter results by SSID
     * @param {int} vlan (optional) Filter results by VLAN
     * @param {string} apTag (optional) Filter results by AP Tag
     * @param {string} fields (optional) Partial selection: If present, this call will return only
     * the selected fields of ["rawDistribution", "avg"]. All fields will be
     * returned by default. Selected fields must be entered as a comma
     * separated string.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessClientLatencyStats(networkId,
        clientId,
        t0,
        t1,
        timespan,
        band,
        ssid,
        vlan,
        apTag,
        fields,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/clients/{clientId}/latencyStats';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            clientId: { value: clientId, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            t0,
            t1,
            timespan,
            band: (band !== null) ? band : null,
            ssid,
            vlan,
            apTag,
            fields,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Aggregated connectivity info for this network
     *
     * @param {string} networkId TODO: type description here
     * @param {string} t0 (optional) The beginning of the timespan for the data. The maximum
     * lookback period is 180 days from today.
     * @param {string} t1 (optional) The end of the timespan for the data. t1 can be a maximum of 7
     * days after t0.
     * @param {double} timespan (optional) The timespan for which the information will be fetched.
     * If specifying timespan, do not specify parameters t0 and t1. The
     * value must be in seconds and be less than or equal to 7 days.
     * @param {BandEnum} band (optional) Filter results by band (either '2.4' or '5'). Note that
     * data prior to February 2020 will not have band information.
     * @param {int} ssid (optional) Filter results by SSID
     * @param {int} vlan (optional) Filter results by VLAN
     * @param {string} apTag (optional) Filter results by AP Tag
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessConnectionStats(networkId,
        t0,
        t1,
        timespan,
        band,
        ssid,
        vlan,
        apTag,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/connectionStats';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            t0,
            t1,
            timespan,
            band: (band !== null) ? band : null,
            ssid,
            vlan,
            apTag,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Return PHY data rates over time for a network, device, or network client
     *
     * @param {string} networkId TODO: type description here
     * @param {string} t0 (optional) The beginning of the timespan for the data. The maximum
     * lookback period is 31 days from today.
     * @param {string} t1 (optional) The end of the timespan for the data. t1 can be a maximum of
     * 31 days after t0.
     * @param {double} timespan (optional) The timespan for which the information will be fetched.
     * If specifying timespan, do not specify parameters t0 and t1. The
     * value must be in seconds and be less than or equal to 31 days. The
     * default is 7 days.
     * @param {int} resolution (optional) The time resolution in seconds for returned data. The
     * valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The
     * default is 86400.
     * @param {bool} autoResolution (optional) Automatically select a data resolution based on the
     * given timespan; this overrides the value specified by the
     * 'resolution' parameter. The default setting is false.
     * @param {string} clientId (optional) Filter results by network client.
     * @param {string} deviceSerial (optional) Filter results by device.
     * @param {string} apTag (optional) Filter results by AP tag.
     * @param {BandEnum} band (optional) Filter results by band (either '2.4' or '5').
     * @param {int} ssid (optional) Filter results by SSID number.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessDataRateHistory(networkId,
        t0,
        t1,
        timespan,
        resolution,
        autoResolution,
        clientId,
        deviceSerial,
        apTag,
        band,
        ssid,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/dataRateHistory';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            t0,
            t1,
            timespan,
            resolution,
            autoResolution,
            clientId,
            deviceSerial,
            apTag,
            band: (band !== null) ? band : null,
            ssid,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Aggregated connectivity info for this network, grouped by node
     *
     * @param {string} networkId TODO: type description here
     * @param {string} t0 (optional) The beginning of the timespan for the data. The maximum
     * lookback period is 180 days from today.
     * @param {string} t1 (optional) The end of the timespan for the data. t1 can be a maximum of 7
     * days after t0.
     * @param {double} timespan (optional) The timespan for which the information will be fetched.
     * If specifying timespan, do not specify parameters t0 and t1. The
     * value must be in seconds and be less than or equal to 7 days.
     * @param {BandEnum} band (optional) Filter results by band (either '2.4' or '5'). Note that
     * data prior to February 2020 will not have band information.
     * @param {int} ssid (optional) Filter results by SSID
     * @param {int} vlan (optional) Filter results by VLAN
     * @param {string} apTag (optional) Filter results by AP Tag
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessDevicesConnectionStats(networkId,
        t0,
        t1,
        timespan,
        band,
        ssid,
        vlan,
        apTag,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/devices/connectionStats';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            t0,
            t1,
            timespan,
            band: (band !== null) ? band : null,
            ssid,
            vlan,
            apTag,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Aggregated latency info for this network, grouped by node
     *
     * @param {string} networkId TODO: type description here
     * @param {string} t0 (optional) The beginning of the timespan for the data. The maximum
     * lookback period is 180 days from today.
     * @param {string} t1 (optional) The end of the timespan for the data. t1 can be a maximum of 7
     * days after t0.
     * @param {double} timespan (optional) The timespan for which the information will be fetched.
     * If specifying timespan, do not specify parameters t0 and t1. The
     * value must be in seconds and be less than or equal to 7 days.
     * @param {BandEnum} band (optional) Filter results by band (either '2.4' or '5'). Note that
     * data prior to February 2020 will not have band information.
     * @param {int} ssid (optional) Filter results by SSID
     * @param {int} vlan (optional) Filter results by VLAN
     * @param {string} apTag (optional) Filter results by AP Tag
     * @param {string} fields (optional) Partial selection: If present, this call will return only
     * the selected fields of ["rawDistribution", "avg"]. All fields will be
     * returned by default. Selected fields must be entered as a comma
     * separated string.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessDevicesLatencyStats(networkId,
        t0,
        t1,
        timespan,
        band,
        ssid,
        vlan,
        apTag,
        fields,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/devices/latencyStats';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            t0,
            t1,
            timespan,
            band: (band !== null) ? band : null,
            ssid,
            vlan,
            apTag,
            fields,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * List of all failed client connection events on this network in a given time range
     *
     * @param {string} networkId TODO: type description here
     * @param {string} t0 (optional) The beginning of the timespan for the data. The maximum
     * lookback period is 180 days from today.
     * @param {string} t1 (optional) The end of the timespan for the data. t1 can be a maximum of 7
     * days after t0.
     * @param {double} timespan (optional) The timespan for which the information will be fetched.
     * If specifying timespan, do not specify parameters t0 and t1. The
     * value must be in seconds and be less than or equal to 7 days.
     * @param {BandEnum} band (optional) Filter results by band (either '2.4' or '5'). Note that
     * data prior to February 2020 will not have band information.
     * @param {int} ssid (optional) Filter results by SSID
     * @param {int} vlan (optional) Filter results by VLAN
     * @param {string} apTag (optional) Filter results by AP Tag
     * @param {string} serial (optional) Filter by AP
     * @param {string} clientId (optional) Filter by client MAC
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessFailedConnections(networkId,
        t0,
        t1,
        timespan,
        band,
        ssid,
        vlan,
        apTag,
        serial,
        clientId,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/failedConnections';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            t0,
            t1,
            timespan,
            band: (band !== null) ? band : null,
            ssid,
            vlan,
            apTag,
            serial,
            clientId,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Return average wireless latency over time for a network, device, or network client
     *
     * @param {string} networkId TODO: type description here
     * @param {string} t0 (optional) The beginning of the timespan for the data. The maximum
     * lookback period is 31 days from today.
     * @param {string} t1 (optional) The end of the timespan for the data. t1 can be a maximum of
     * 31 days after t0.
     * @param {double} timespan (optional) The timespan for which the information will be fetched.
     * If specifying timespan, do not specify parameters t0 and t1. The
     * value must be in seconds and be less than or equal to 31 days. The
     * default is 7 days.
     * @param {int} resolution (optional) The time resolution in seconds for returned data. The
     * valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The
     * default is 86400.
     * @param {bool} autoResolution (optional) Automatically select a data resolution based on the
     * given timespan; this overrides the value specified by the
     * 'resolution' parameter. The default setting is false.
     * @param {string} clientId (optional) Filter results by network client.
     * @param {string} deviceSerial (optional) Filter results by device.
     * @param {string} apTag (optional) Filter results by AP tag.
     * @param {BandEnum} band (optional) Filter results by band (either '2.4' or '5').
     * @param {int} ssid (optional) Filter results by SSID number.
     * @param {AccessCategoryEnum} accessCategory (optional) Filter by access category.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessLatencyHistory(networkId,
        t0,
        t1,
        timespan,
        resolution,
        autoResolution,
        clientId,
        deviceSerial,
        apTag,
        band,
        ssid,
        accessCategory,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/latencyHistory';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            t0,
            t1,
            timespan,
            resolution,
            autoResolution,
            clientId,
            deviceSerial,
            apTag,
            band: (band !== null) ? band : null,
            ssid,
            accessCategory: (accessCategory !== null) ? accessCategory : null,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Aggregated latency info for this network
     *
     * @param {string} networkId TODO: type description here
     * @param {string} t0 (optional) The beginning of the timespan for the data. The maximum
     * lookback period is 180 days from today.
     * @param {string} t1 (optional) The end of the timespan for the data. t1 can be a maximum of 7
     * days after t0.
     * @param {double} timespan (optional) The timespan for which the information will be fetched.
     * If specifying timespan, do not specify parameters t0 and t1. The
     * value must be in seconds and be less than or equal to 7 days.
     * @param {BandEnum} band (optional) Filter results by band (either '2.4' or '5'). Note that
     * data prior to February 2020 will not have band information.
     * @param {int} ssid (optional) Filter results by SSID
     * @param {int} vlan (optional) Filter results by VLAN
     * @param {string} apTag (optional) Filter results by AP Tag
     * @param {string} fields (optional) Partial selection: If present, this call will return only
     * the selected fields of ["rawDistribution", "avg"]. All fields will be
     * returned by default. Selected fields must be entered as a comma
     * separated string.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessLatencyStats(networkId,
        t0,
        t1,
        timespan,
        band,
        ssid,
        vlan,
        apTag,
        fields,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/latencyStats';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            t0,
            t1,
            timespan,
            band: (band !== null) ? band : null,
            ssid,
            vlan,
            apTag,
            fields,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * List wireless mesh statuses for repeaters
     *
     * @param {string} networkId TODO: type description here
     * @param {int} perPage (optional) The number of entries per page returned. Acceptable range is
     * 3 - 500. Default is 50.
     * @param {string} startingAfter (optional) A token used by the server to indicate the start of
     * the page. Often this is a timestamp or an ID but it is not
     * limited to those. This parameter should not be defined by
     * client applications. The link for the first, last, prev, or
     * next page in the HTTP Link header should define it.
     * @param {string} endingBefore (optional) A token used by the server to indicate the end of
     * the page. Often this is a timestamp or an ID but it is not
     * limited to those. This parameter should not be defined by
     * client applications. The link for the first, last, prev, or
     * next page in the HTTP Link header should define it.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessMeshStatuses(networkId,
        perPage,
        startingAfter,
        endingBefore,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/meshStatuses';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            perPage,
            startingAfter,
            endingBefore,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * List the non-basic RF profiles for this network
     *
     * @param {string} networkId TODO: type description here
     * @param {bool} includeTemplateProfiles (optional) If the network is bound to a template, this
     * parameter controls whether or not the non-basic RF
     * profiles defined on the template should be included in
     * the response alongside the non-basic profiles defined
     * on the bound network. Defaults to false.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessRfProfiles(networkId, includeTemplateProfiles, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/rfProfiles';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            includeTemplateProfiles,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Creates new RF profile for this network
     *
     * @param {string} networkId TODO: type description here
     * @param {CreateNetworkWirelessRfProfile} createNetworkWirelessRfProfile TODO: type
     * description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createNetworkWirelessRfProfile(networkId, createNetworkWirelessRfProfile, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/rfProfiles';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(createNetworkWirelessRfProfile),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Updates specified RF profile for this network
     *
     * @param {string} networkId TODO: type description here
     * @param {string} rfProfileId TODO: type description here
     * @param {UpdateNetworkWirelessRfProfile} updateNetworkWirelessRfProfile (optional) TODO: type
     * description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateNetworkWirelessRfProfile(networkId,
        rfProfileId,
        updateNetworkWirelessRfProfile,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/rfProfiles/{rfProfileId}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            rfProfileId: { value: rfProfileId, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(updateNetworkWirelessRfProfile),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Delete a RF Profile
     *
     * @param {string} networkId TODO: type description here
     * @param {string} rfProfileId TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static deleteNetworkWirelessRfProfile(networkId, rfProfileId, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/rfProfiles/{rfProfileId}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            rfProfileId: { value: rfProfileId, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'DELETE',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Return a RF profile
     *
     * @param {string} networkId TODO: type description here
     * @param {string} rfProfileId TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessRfProfile(networkId, rfProfileId, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/rfProfiles/{rfProfileId}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            rfProfileId: { value: rfProfileId, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Return the wireless settings for a network
     *
     * @param {string} networkId TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessSettings(networkId, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/settings';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Update the wireless settings for a network
     *
     * @param {string} networkId TODO: type description here
     * @param {UpdateNetworkWirelessSettings} updateNetworkWirelessSettings (optional) TODO: type
     * description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateNetworkWirelessSettings(networkId, updateNetworkWirelessSettings, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/settings';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(updateNetworkWirelessSettings),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Return signal quality (SNR/RSSI) over time for a device or network client
     *
     * @param {string} networkId TODO: type description here
     * @param {string} t0 (optional) The beginning of the timespan for the data. The maximum
     * lookback period is 31 days from today.
     * @param {string} t1 (optional) The end of the timespan for the data. t1 can be a maximum of
     * 31 days after t0.
     * @param {double} timespan (optional) The timespan for which the information will be fetched.
     * If specifying timespan, do not specify parameters t0 and t1. The
     * value must be in seconds and be less than or equal to 31 days. The
     * default is 7 days.
     * @param {int} resolution (optional) The time resolution in seconds for returned data. The
     * valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The
     * default is 86400.
     * @param {bool} autoResolution (optional) Automatically select a data resolution based on the
     * given timespan; this overrides the value specified by the
     * 'resolution' parameter. The default setting is false.
     * @param {string} clientId (optional) Filter results by network client.
     * @param {string} deviceSerial (optional) Filter results by device.
     * @param {string} apTag (optional) Filter results by AP tag; either :clientId or :deviceSerial
     * must be jointly specified.
     * @param {BandEnum} band (optional) Filter results by band (either '2.4' or '5').
     * @param {int} ssid (optional) Filter results by SSID number.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessSignalQualityHistory(networkId,
        t0,
        t1,
        timespan,
        resolution,
        autoResolution,
        clientId,
        deviceSerial,
        apTag,
        band,
        ssid,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/signalQualityHistory';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            t0,
            t1,
            timespan,
            resolution,
            autoResolution,
            clientId,
            deviceSerial,
            apTag,
            band: (band !== null) ? band : null,
            ssid,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * List the MR SSIDs in a network
     *
     * @param {string} networkId TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessSsids(networkId, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/ssids';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Return a single MR SSID
     *
     * @param {string} networkId TODO: type description here
     * @param {string} number TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessSsid(networkId, number, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/ssids/{number}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            number: { value: number, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Update the attributes of an MR SSID
     *
     * @param {string} networkId TODO: type description here
     * @param {string} number TODO: type description here
     * @param {UpdateNetworkWirelessSsid} updateNetworkWirelessSsid (optional) TODO: type
     * description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateNetworkWirelessSsid(networkId, number, updateNetworkWirelessSsid, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/ssids/{number}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            number: { value: number, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(updateNetworkWirelessSsid),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * List the Bonjour forwarding setting and rules for the SSID
     *
     * @param {string} networkId TODO: type description here
     * @param {string} number TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessSsidBonjourForwarding(networkId, number, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/ssids/{number}/bonjourForwarding';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            number: { value: number, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Update the bonjour forwarding setting and rules for the SSID
     *
     * @param {string} networkId TODO: type description here
     * @param {string} number TODO: type description here
     * @param {UpdateNetworkWirelessSsidBonjourForwarding} updateNetworkWirelessSsidBonjourForwarding (optional) TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateNetworkWirelessSsidBonjourForwarding(networkId,
        number,
        updateNetworkWirelessSsidBonjourForwarding,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/ssids/{number}/bonjourForwarding';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            number: { value: number, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(updateNetworkWirelessSsidBonjourForwarding),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * List the device type group policies for the SSID
     *
     * @param {string} networkId TODO: type description here
     * @param {string} number TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessSsidDeviceTypeGroupPolicies(networkId, number, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/ssids/{number}/deviceTypeGroupPolicies';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            number: { value: number, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Update the device type group policies for the SSID
     *
     * @param {string} networkId TODO: type description here
     * @param {string} number TODO: type description here
     * @param {UpdateNetworkWirelessSsidDeviceTypeGroupPolicies} updateNetworkWirelessSsidDeviceTypeGroupPolicies (optional) TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateNetworkWirelessSsidDeviceTypeGroupPolicies(networkId,
        number,
        updateNetworkWirelessSsidDeviceTypeGroupPolicies,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/ssids/{number}/deviceTypeGroupPolicies';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            number: { value: number, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(updateNetworkWirelessSsidDeviceTypeGroupPolicies),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Return the L3 firewall rules for an SSID on an MR network
     *
     * @param {string} networkId TODO: type description here
     * @param {string} number TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessSsidFirewallL3FirewallRules(networkId, number, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/ssids/{number}/firewall/l3FirewallRules';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            number: { value: number, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Update the L3 firewall rules of an SSID on an MR network
     *
     * @param {string} networkId TODO: type description here
     * @param {string} number TODO: type description here
     * @param {UpdateNetworkWirelessSsidFirewallL3FirewallRules} updateNetworkWirelessSsidFirewallL3FirewallRules (optional) TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateNetworkWirelessSsidFirewallL3FirewallRules(networkId,
        number,
        updateNetworkWirelessSsidFirewallL3FirewallRules,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/ssids/{number}/firewall/l3FirewallRules';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            number: { value: number, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(updateNetworkWirelessSsidFirewallL3FirewallRules),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Return the L7 firewall rules for an SSID on an MR network
     *
     * @param {string} networkId TODO: type description here
     * @param {string} number TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessSsidFirewallL7FirewallRules(networkId, number, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/ssids/{number}/firewall/l7FirewallRules';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            number: { value: number, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Update the L7 firewall rules of an SSID on an MR network
     *
     * @param {string} networkId TODO: type description here
     * @param {string} number TODO: type description here
     * @param {UpdateNetworkWirelessSsidFirewallL7FirewallRules} updateNetworkWirelessSsidFirewallL7FirewallRules (optional) TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateNetworkWirelessSsidFirewallL7FirewallRules(networkId,
        number,
        updateNetworkWirelessSsidFirewallL7FirewallRules,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/ssids/{number}/firewall/l7FirewallRules';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            number: { value: number, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(updateNetworkWirelessSsidFirewallL7FirewallRules),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * List all Identity PSKs in a wireless network
     *
     * @param {string} networkId TODO: type description here
     * @param {string} number TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessSsidIdentityPsks(networkId, number, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/ssids/{number}/identityPsks';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            number: { value: number, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Create an Identity PSK
     *
     * @param {string} networkId TODO: type description here
     * @param {string} number TODO: type description here
     * @param {CreateNetworkWirelessSsidIdentityPsk} createNetworkWirelessSsidIdentityPsk TODO:
     * type
     * descripti
     * on here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createNetworkWirelessSsidIdentityPsk(networkId,
        number,
        createNetworkWirelessSsidIdentityPsk,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/ssids/{number}/identityPsks';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            number: { value: number, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(createNetworkWirelessSsidIdentityPsk),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Return an Identity PSK
     *
     * @param {string} networkId TODO: type description here
     * @param {string} number TODO: type description here
     * @param {string} identityPskId TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessSsidIdentityPsk(networkId, number, identityPskId, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            number: { value: number, encode: true },
            identityPskId: { value: identityPskId, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Update an Identity PSK
     *
     * @param {string} networkId TODO: type description here
     * @param {string} number TODO: type description here
     * @param {string} identityPskId TODO: type description here
     * @param {UpdateNetworkWirelessSsidIdentityPsk} updateNetworkWirelessSsidIdentityPsk (optional
     * ) TODO:
     * type
     * descripti
     * on here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateNetworkWirelessSsidIdentityPsk(networkId,
        number,
        identityPskId,
        updateNetworkWirelessSsidIdentityPsk,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            number: { value: number, encode: true },
            identityPskId: { value: identityPskId, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(updateNetworkWirelessSsidIdentityPsk),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Delete an Identity PSK
     *
     * @param {string} networkId TODO: type description here
     * @param {string} number TODO: type description here
     * @param {string} identityPskId TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static deleteNetworkWirelessSsidIdentityPsk(networkId, number, identityPskId, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            number: { value: number, encode: true },
            identityPskId: { value: identityPskId, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'DELETE',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Display the splash page settings for the given SSID
     *
     * @param {string} networkId TODO: type description here
     * @param {string} number TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessSsidSplashSettings(networkId, number, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/ssids/{number}/splash/settings';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            number: { value: number, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Modify the splash page settings for the given SSID
     *
     * @param {string} networkId TODO: type description here
     * @param {string} number TODO: type description here
     * @param {UpdateNetworkWirelessSsidSplashSettings} updateNetworkWirelessSsidSplashSettings (op
     * tio
     * nal
     * )
     * TOD
     * O:
     * typ
     * e
     * des
     * cri
     * pti
     * on
     * her
     * e
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateNetworkWirelessSsidSplashSettings(networkId,
        number,
        updateNetworkWirelessSsidSplashSettings,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/ssids/{number}/splash/settings';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            number: { value: number, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(updateNetworkWirelessSsidSplashSettings),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Update the traffic shaping settings for an SSID on an MR network
     *
     * @param {string} networkId TODO: type description here
     * @param {string} number TODO: type description here
     * @param {UpdateNetworkWirelessSsidTrafficShapingRules} updateNetworkWirelessSsidTrafficShapingRules (optional) TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateNetworkWirelessSsidTrafficShapingRules(networkId,
        number,
        updateNetworkWirelessSsidTrafficShapingRules,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/ssids/{number}/trafficShaping/rules';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            number: { value: number, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(updateNetworkWirelessSsidTrafficShapingRules),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Display the traffic shaping settings for a SSID on an MR network
     *
     * @param {string} networkId TODO: type description here
     * @param {string} number TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessSsidTrafficShapingRules(networkId, number, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/ssids/{number}/trafficShaping/rules';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            number: { value: number, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * List the VPN settings for the SSID.
     *
     * @param {string} networkId TODO: type description here
     * @param {string} number TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessSsidVpn(networkId, number, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/ssids/{number}/vpn';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            number: { value: number, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Update the VPN settings for the SSID
     *
     * @param {string} networkId TODO: type description here
     * @param {string} number TODO: type description here
     * @param {UpdateNetworkWirelessSsidVpn} updateNetworkWirelessSsidVpn (optional) TODO: type
     * description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateNetworkWirelessSsidVpn(networkId,
        number,
        updateNetworkWirelessSsidVpn,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/ssids/{number}/vpn';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
            number: { value: number, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(updateNetworkWirelessSsidVpn),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Return AP usage over time for a device or network client
     *
     * @param {string} networkId TODO: type description here
     * @param {string} t0 (optional) The beginning of the timespan for the data. The maximum
     * lookback period is 31 days from today.
     * @param {string} t1 (optional) The end of the timespan for the data. t1 can be a maximum of
     * 31 days after t0.
     * @param {double} timespan (optional) The timespan for which the information will be fetched.
     * If specifying timespan, do not specify parameters t0 and t1. The
     * value must be in seconds and be less than or equal to 31 days. The
     * default is 7 days.
     * @param {int} resolution (optional) The time resolution in seconds for returned data. The
     * valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The
     * default is 86400.
     * @param {bool} autoResolution (optional) Automatically select a data resolution based on the
     * given timespan; this overrides the value specified by the
     * 'resolution' parameter. The default setting is false.
     * @param {string} clientId (optional) Filter results by network client to return per-device AP
     * usage over time inner joined by the queried client's connection
     * history.
     * @param {string} deviceSerial (optional) Filter results by device. Requires :band.
     * @param {string} apTag (optional) Filter results by AP tag; either :clientId or :deviceSerial
     * must be jointly specified.
     * @param {BandEnum} band (optional) Filter results by band (either '2.4' or '5').
     * @param {int} ssid (optional) Filter results by SSID number.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getNetworkWirelessUsageHistory(networkId,
        t0,
        t1,
        timespan,
        resolution,
        autoResolution,
        clientId,
        deviceSerial,
        apTag,
        band,
        ssid,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/networks/{networkId}/wireless/usageHistory';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            networkId: { value: networkId, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            t0,
            t1,
            timespan,
            resolution,
            autoResolution,
            clientId,
            deviceSerial,
            apTag,
            band: (band !== null) ? band : null,
            ssid,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'X-Cisco-Meraki-API-Key': _configuration.xCiscoMerakiAPIKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const _strResult = _response.body;
                    const _result = JSON.parse(_strResult);
                    _callback(null, _result, _context);
                    _fulfill(_result);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
}
module.exports = WirelessController;
